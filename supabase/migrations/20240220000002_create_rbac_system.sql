-- Custom types for permissions and roles
CREATE TYPE public.app_permission AS ENUM (
    'tasks.create',
    'tasks.update',
    'tasks.delete',
    'tasks.read_all',
    'users.manage'
);

CREATE TYPE public.app_role AS ENUM (
    'admin',
    'manager',
    'user'
);

-- Create table for user roles
CREATE TABLE public.user_roles (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID REFERENCES auth.users ON DELETE CASCADE NOT NULL,
    role app_role NOT NULL DEFAULT 'user',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
    UNIQUE (user_id, role)
);
COMMENT ON TABLE public.user_roles IS 'Application roles for each user.';

-- Create table for role permissions
CREATE TABLE public.role_permissions (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    role app_role NOT NULL,
    permission app_permission NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
    UNIQUE (role, permission)
);
COMMENT ON TABLE public.role_permissions IS 'Application permissions for each role.';

-- Insert default roles and permissions
INSERT INTO public.role_permissions (role, permission)
VALUES
    -- Admin can do everything
    ('admin', 'tasks.create'),
    ('admin', 'tasks.update'),
    ('admin', 'tasks.delete'),
    ('admin', 'tasks.read_all'),
    ('admin', 'users.manage'),
    -- Manager can manage tasks but not users
    ('manager', 'tasks.create'),
    ('manager', 'tasks.update'),
    ('manager', 'tasks.delete'),
    ('manager', 'tasks.read_all'),
    -- Regular user can only create and update their own tasks
    ('user', 'tasks.create'),
    ('user', 'tasks.update');

-- Create the authorization function
CREATE OR REPLACE FUNCTION public.authorize(
    requested_permission app_permission
)
RETURNS BOOLEAN AS $$
DECLARE
    bind_permissions INT;
    user_role public.app_role;
BEGIN
    -- Get the user role from JWT
    SELECT (auth.jwt() ->> 'user_role')::public.app_role INTO user_role;

    -- Count matching permissions for the role
    SELECT COUNT(*)
    INTO bind_permissions
    FROM public.role_permissions
    WHERE role_permissions.permission = requested_permission
        AND role_permissions.role = user_role;

    RETURN bind_permissions > 0;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER SET search_path = '';

-- Create the auth hook function
CREATE OR REPLACE FUNCTION public.custom_access_token_hook(event JSONB)
RETURNS JSONB
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
    claims JSONB;
    user_role public.app_role;
BEGIN
    -- Fetch the user role from user_roles table
    SELECT role INTO user_role 
    FROM public.user_roles 
    WHERE user_id = (event->>'user_id')::uuid;

    claims := event->'claims';

    IF user_role IS NOT NULL THEN
        -- Set the claim
        claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
    ELSE
        -- If no role is set, default to 'user'
        claims := jsonb_set(claims, '{user_role}', '"user"');
    END IF;

    -- Update the claims in the event
    event := jsonb_set(event, '{claims}', claims);

    RETURN event;
END;
$$;

-- Grant necessary permissions
GRANT USAGE ON SCHEMA public TO supabase_auth_admin;

GRANT EXECUTE ON FUNCTION public.custom_access_token_hook TO supabase_auth_admin;
REVOKE EXECUTE ON FUNCTION public.custom_access_token_hook FROM authenticated, anon, public;

GRANT ALL ON TABLE public.user_roles TO supabase_auth_admin;
REVOKE ALL ON TABLE public.user_roles FROM authenticated, anon, public;

-- Enable RLS
ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.role_permissions ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Allow users to read their own roles" ON public.user_roles
    FOR SELECT TO authenticated
    USING (auth.uid() = user_id);

CREATE POLICY "Allow auth admin to read user roles" ON public.user_roles
    AS PERMISSIVE FOR SELECT
    TO supabase_auth_admin
    USING (true);

CREATE POLICY "Allow users to read role permissions" ON public.role_permissions
    FOR SELECT TO authenticated
    USING (true); 